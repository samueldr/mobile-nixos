From e97ed214f42655b45172b53b52af8ec0364b7dcc Mon Sep 17 00:00:00 2001
From: Liam Mark <lmark@codeaurora.org>
Date: Wed, 17 May 2017 17:03:48 -0700
Subject: iommu: iommu-debug: cleanup iommu debug

Only expose debugfs nodes for test devices.
Restrict secure attach to a valid vmid.
Add clock reference counting to make code more robust.
Restrict address printing with kptr_restrict.

Change-Id: Ibf90068d778b0156e3bb42287af5dda3864da5fc
Signed-off-by: Liam Mark <lmark@codeaurora.org>
---
 drivers/iommu/iommu-debug.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/drivers/iommu/iommu-debug.c b/drivers/iommu/iommu-debug.c
index 5f47e60..9a0aba0 100644
--- a/drivers/iommu/iommu-debug.c
+++ b/drivers/iommu/iommu-debug.c
@@ -165,6 +165,8 @@ struct iommu_debug_device {
 	u64 phys;
 	size_t len;
 	struct list_head list;
+	struct mutex clk_lock;
+	unsigned int clk_count;
 };
 
 static int iommu_debug_build_phoney_sg_table(struct device *dev,
@@ -1203,6 +1205,7 @@ static int iommu_debug_attach_do_attach(struct iommu_debug_device *ddev,
 		goto out_domain_free;
 	}
 
+	val = VMID_CP_CAMERA;
 	if (is_secure && iommu_domain_set_attr(ddev->domain,
 					       DOMAIN_ATTR_SECURE_VMID,
 					       &val)) {
@@ -1348,6 +1351,10 @@ static ssize_t iommu_debug_atos_read(struct file *file, char __user *ubuf,
 	ssize_t retval;
 	size_t buflen;
 
+	if (kptr_restrict != 0) {
+		pr_err("kptr_restrict needs to be disabled.\n");
+		return -EPERM;
+	}
 	if (!ddev->domain) {
 		pr_err("No domain. Did you already attach?\n");
 		return -EINVAL;
@@ -1555,20 +1562,34 @@ static ssize_t iommu_debug_config_clocks_write(struct file *file,
 		return -EFAULT;
 	}
 
+	mutex_lock(&ddev->clk_lock);
 	switch (buf) {
 	case '0':
+		if (ddev->clk_count == 0) {
+			dev_err(dev, "Config clocks already disabled\n");
+			break;
+		}
+
+		if (--ddev->clk_count > 0)
+			break;
+
 		dev_err(dev, "Disabling config clocks\n");
 		iommu_disable_config_clocks(ddev->domain);
 		break;
 	case '1':
+		if (ddev->clk_count++ > 0)
+			break;
+
 		dev_err(dev, "Enabling config clocks\n");
 		if (iommu_enable_config_clocks(ddev->domain))
 			dev_err(dev, "Failed!\n");
 		break;
 	default:
 		dev_err(dev, "Invalid value. Should be 0 or 1.\n");
+		mutex_unlock(&ddev->clk_lock);
 		return -EINVAL;
 	}
+	mutex_unlock(&ddev->clk_lock);
 
 	return count;
 }
@@ -1594,6 +1615,7 @@ static int snarf_iommu_devices(struct device *dev, const char *name)
 	ddev = kzalloc(sizeof(*ddev), GFP_KERNEL);
 	if (!ddev)
 		return -ENODEV;
+	mutex_init(&ddev->clk_lock);
 	ddev->dev = dev;
 	dir = debugfs_create_dir(name, debugfs_tests_dir);
 	if (!dir) {
@@ -1705,6 +1727,9 @@ err:
 
 static int pass_iommu_devices(struct device *dev, void *ignored)
 {
+	if (!of_device_is_compatible(dev->of_node, "iommu-debug-test"))
+		return 0;
+
 	if (!of_find_property(dev->of_node, "iommus", NULL))
 		return 0;
 
@@ -1718,6 +1743,9 @@ static int iommu_debug_populate_devices(void)
 	const char *cb_name;
 
 	for_each_compatible_node(np, NULL, "qcom,msm-smmu-v2-ctx") {
+		if (!of_device_is_compatible(np, "iommu-debug-test"))
+			continue;
+
 		ret = of_property_read_string(np, "label", &cb_name);
 		if (ret)
 			return ret;
-- 
cgit v1.1

